{
  "name": "[Email Classifier] 01 - Email Reader",
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "minutes",
              "minutesInterval": 2
            }
          ]
        }
      },
      "id": "schedule-trigger",
      "name": "Every 2 Minutes",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.1,
      "position": [250, 300]
    },
    {
      "parameters": {
        "operation": "getAll",
        "returnAll": false,
        "limit": 50,
        "filters": {
          "labelIds": ["INBOX"],
          "q": "is:unread"
        },
        "simplifyOutput": true
      },
      "id": "gmail-trigger",
      "name": "Gmail - Get Unread Emails",
      "type": "n8n-nodes-base.gmail",
      "typeVersion": 2.1,
      "position": [450, 300],
      "credentials": {
        "gmailOAuth2": {
          "id": "GMAIL_OAUTH2_ID",
          "name": "Gmail OAuth2"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const items = $input.all();\nconst results = [];\n\nfor (const item of items) {\n  const email = item.json;\n  \n  // Extract basic info\n  const emailData = {\n    email_id: email.id || email.messageId,\n    thread_id: email.threadId,\n    from_email: email.from || '',\n    to_email: email.to || '',\n    subject: email.subject || '(Sem assunto)',\n    body_text: email.snippet || email.plainText || '',\n    body_html: email.bodyHtml || '',\n    received_at: email.internalDate ? new Date(parseInt(email.internalDate)).toISOString() : new Date().toISOString(),\n    labels: email.labelIds || [],\n    has_attachments: (email.attachments && email.attachments.length > 0) || false,\n    attachments_count: email.attachments ? email.attachments.length : 0,\n    status: 'pending_classification'\n  };\n  \n  results.push({ json: emailData });\n}\n\nreturn results;"
      },
      "id": "code-transform",
      "name": "Transform Email Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [650, 300]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO automation_email_classifier.emails (\n  email_id, thread_id, from_email, to_email, subject, \n  body_text, body_html, received_at, labels, \n  has_attachments, attachments_count, status, created_at\n)\nVALUES (\n  $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, NOW()\n)\nON CONFLICT (email_id) DO NOTHING\nRETURNING id;",
        "additionalFields": {}
      },
      "id": "postgres-insert",
      "name": "PostgreSQL - Insert Email",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [850, 300],
      "credentials": {
        "postgres": {
          "id": "POSTGRES_CRED_ID",
          "name": "PostgreSQL - bdn8n"
        }
      },
      "executeOnce": false
    },
    {
      "parameters": {
        "conditions": {
          "number": [
            {
              "value1": "={{ $json.id }}",
              "operation": "isNotEmpty"
            }
          ]
        }
      },
      "id": "if-inserted",
      "name": "If Inserted Successfully",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [1050, 300]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "UPDATE automation_email_classifier.emails \nSET status = 'pending_classification', updated_at = NOW() \nWHERE id = $1;",
        "additionalFields": {}
      },
      "id": "postgres-update-status",
      "name": "Mark as Pending Classification",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [1250, 200],
      "credentials": {
        "postgres": {
          "id": "POSTGRES_CRED_ID",
          "name": "PostgreSQL - bdn8n"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO automation_email_classifier.execution_logs (\n  workflow_name, execution_status, processed_count, \n  error_message, execution_data\n)\nVALUES (\n  'Email Reader', 'success', $1, NULL, $2::jsonb\n);",
        "additionalFields": {}
      },
      "id": "log-success",
      "name": "Log Success",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [1450, 200],
      "credentials": {
        "postgres": {
          "id": "POSTGRES_CRED_ID",
          "name": "PostgreSQL - bdn8n"
        }
      }
    }
  ],
  "connections": {
    "Every 2 Minutes": {
      "main": [
        [
          {
            "node": "Gmail - Get Unread Emails",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Gmail - Get Unread Emails": {
      "main": [
        [
          {
            "node": "Transform Email Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Transform Email Data": {
      "main": [
        [
          {
            "node": "PostgreSQL - Insert Email",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "PostgreSQL - Insert Email": {
      "main": [
        [
          {
            "node": "If Inserted Successfully",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If Inserted Successfully": {
      "main": [
        [
          {
            "node": "Mark as Pending Classification",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Mark as Pending Classification": {
      "main": [
        [
          {
            "node": "Log Success",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [],
  "triggerCount": 1,
  "updatedAt": "2025-12-29T00:00:00.000Z",
  "versionId": "1"
}
